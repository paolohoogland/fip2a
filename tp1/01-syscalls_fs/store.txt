
  /* ********** PRINT IN REVERSE ********** */
  int fd = -1;
  off_t file_size = 0;
  off_t current_pos = 0;
  char buffer;
  ssize_t bytes_read;

  // open file
  fd = open(bin_input_param, O_RDONLY);
  if (fd == -1)
  {
      dprintf(STDERR, "Error: Cannot open input file '%s': %s\n", bin_input_param, strerror(errno));
      free_if_needed(bin_input_param);
      exit(EXIT_FAILURE);
  }

  // get file size
  file_size = lseek(fd, 0, SEEK_END);

  if (file_size == -1)
  {
      dprintf(STDERR, "Error: Cannot determine size of file '%s': %s\n", bin_input_param, strerror(errno));
      close(fd);
      free_if_needed(bin_input_param);
      exit(EXIT_FAILURE);
  }

  // read file in reverse
  for (current_pos = file_size - 1; current_pos >= 0; current_pos--)
  {
      if (lseek(fd, current_pos, SEEK_SET) == -1) // move pointer back one byte
      {
          dprintf(STDERR, "Error: Cannot seek in file '%s': %s\n", bin_input_param, strerror(errno));
          close(fd);
          free_if_needed(bin_input_param);
          exit(EXIT_FAILURE);
      }
      bytes_read = read(fd, &buffer, 1); // read one byte
      if (bytes_read == -1) // error reading
      {
          dprintf(STDERR, "Error: Cannot read from file '%s': %s\n", bin_input_param, strerror(errno));
          close(fd);
          free_if_needed(bin_input_param);
          exit(EXIT_FAILURE);
      }
      if (bytes_read > 0) // successfully read a byte
      {
          // write to stdout
          if (write(STDOUT, &buffer, 1) == -1)
          {
              dprintf(STDERR, "Error: Cannot write to stdout: %s\n", strerror(errno));
              close(fd);
              free_if_needed(bin_input_param);
              exit(EXIT_FAILURE);
          }
      }
  } 

  dprintf(STDOUT, "\n");
  close(fd);

  // ********** END OF OPEN FILE ********** // 

  // ********** LS COMMAND ********** //

  DIR *dirp = NULL;
  struct dirent *dp = NULL;
  struct stat file_stat;
  char full_path[MAX_PATH_LENGTH];

  dirp = opendir(bin_input_param);
  if (dirp == NULL) 
  {
    dprintf(STDERR, "Error: Cannot open directory '%s': %s\n", bin_input_param, strerror(errno));
    free_if_needed(bin_input_param);
    exit(EXIT_FAILURE);
  }

  while ((dp = readdir(dirp)) != NULL) 
  {
    // skip the current directory (.) and parent directory (..)
    if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
    {
      continue;
    }
    
    // construct the full path to the file/folder
    snprintf(full_path, MAX_PATH_LENGTH, "%s/%s", bin_input_param, dp->d_name);
    
    // Get file metadata (using lstat to correctly handle symbolic links)
    if (lstat(full_path, &file_stat) == -1) 
    {
      dprintf(STDERR, "Error: Failed to stat '%s': %s. Skipping.\n", dp->d_name, strerror(errno));
      continue; // Skip file if stat fails
    }

      char perms_str[11]; // Declared
    mode_to_perms(file_stat.st_mode, perms_str); // Populated

    struct passwd *pw = getpwuid(file_stat.st_uid); // Fetched
    struct group *gr = getgrgid(file_stat.st_gid); // Fetched
    
    const char *owner_name = (pw != NULL) ? pw->pw_name : "UID_ERR"; 
    const char *group_name = (gr != NULL) ? gr->gr_name : "GID_ERR";

    char time_str[64]; // Declared
    format_time(file_stat.st_mtime, time_str); // Populated

    dprintf(STDOUT, "%s - %s %s : %s - %lu - %s\n",
        dp->d_name,           // Name
        perms_str,            // Permissions
        owner_name,           // Owner
        group_name,           // Group
        (unsigned long)file_stat.st_size, // Size
        time_str              // Date of last update
    );
  }

  if (errno != 0) 
  {
      dprintf(STDERR, "Error: An error occurred during directory traversal: %s\n", strerror(errno));
      closedir(dirp);
      free_if_needed(bin_input_param);
      exit(EXIT_FAILURE);
  }

  // Close the directory stream
  closedir(dirp);

  // ********** END OF LS COMMAND ********** //
